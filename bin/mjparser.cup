
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // redefined error methods
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        //report_error("Syntax Error", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal Error, parsing interrupted", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info != null) {
    		log.info (info.getClass());
    		log.info (info);
		}
    	if (info instanceof Symbol)
            msg.append (" on line ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}

scan with {:
	
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
	
:}

terminal PROGRAM, BREAK, CONST, CLASS, EXTENDS, IMPLEMENTS, ENUM, INTERFACE, IF, ELSE, FOR, NEW, PRINT, READ, RETURN, VOID, CONTINUE;
terminal String IDENT;
terminal Integer NUMBER;
terminal Character CHAR;
terminal Boolean BOOL;
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal EQUALS, NOT_EQUALS, GREATER_THAN, GREATER_THAN_EQUALS, LESS_THAN, LESS_THAN_EQUALS;
terminal AND, OR, ASSIGN, INC, DEC;
terminal SEMICOLON, COMMA, PERIOD;
terminal LEFT_BRACE, RIGHT_BRACE, LEFT_BRACKET, RIGHT_BRACKET, LEFT_PARENTHESIS, RIGHT_PARENTHESIS;

non terminal Program, DeclarationsList, Decl, MethodDeclarationsList;
non terminal ClassDecl, EnumDecl, InterfaceDecl;
non terminal ConstDecl, ConstSyntaxCheck, MultipleConstDecl, SingleConstDecl, SingleConstDeclSyntaxCheck, ConstValue;
non terminal VarDecl, MultipleVarDecl;
non terminal MethodDecl;
non terminal Type;

Program ::= (Program) PROGRAM IDENT:programName DeclarationsList LEFT_BRACE MethodDeclarationsList RIGHT_BRACE ;

DeclarationsList ::= (GlobalDeclarations) DeclarationsList Decl
                     |
                     (NoGlobalDeclarations) /* epsilon */ ;

Decl ::= (ConstDeclaration) ConstDecl
         |
         (GlobalVariableDeclaration) VarDecl
         | 
         (ClassDeclaration) ClassDecl
         | 
         (EnumDeclaration) EnumDecl 
         | 
         (InterfaceDeclaration) InterfaceDecl ;
                     
MethodDeclarationsList ::= (GlobalMethodsDeclarations) MethodDeclarationsList MethodDecl
                           |
                           (NoGlobalMethodsDeclarations) /* epsilon */ ;                           

         
ConstDecl ::= (ConstDecl) CONST ConstSyntaxCheck SEMICOLON ; 

ConstSyntaxCheck ::= (ConstDeclSuccess) Type:constType MultipleConstDecl
                     |
                     (ConstDeclError) error:e 
                     {: parser.report_error("1Syntax Error on line " + eleft + "; error in constant declaration", null); :}  ;

MultipleConstDecl ::= (MultipleConstDeclaration) MultipleConstDecl COMMA SingleConstDecl
                      |
                      (SingleConstDeclaration) SingleConstDecl ;
                      
SingleConstDecl ::= (SingleConstDecl) SingleConstDeclSyntaxCheck; 

SingleConstDeclSyntaxCheck ::= (SingleConstDeclSuccess) IDENT:constName ASSIGN ConstValue:constValue
                               |
                               (SingleConstDeclError) error:e
                               {: parser.report_error("2Syntax Error on line " + eleft + "; error in constant declaration", null); :} ;

ConstValue ::= (NumConst) NUMBER:numberValue
               |
               (CharConst) CHAR:charValue
               |
               (BoolConst) BOOL:boolValue ;
               
VarDecl ::= (VarDecl) Type:varType MultipleVarDecl SEMICOLON ;
               
Type ::= (Type) IDENT:typeName ;